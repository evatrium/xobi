import{useCallback as e,useRef as t,useEffect as n,useState as o}from"react";const r=e=>"[object Object]"===Object.prototype.toString.call(e),c=(e,t,n)=>Object.defineProperty(e,t,n),a=new Promise(e=>e()),i=e=>Object.keys(e),$=e=>!i(e).length,l=(e,t=!1)=>()=>t||(t=a.then(()=>(e(),t=!1))),s=(e,t)=>(i(t).map(n=>r(e[n])&&r(t[n])?s(e[n],t[n]):e[n]=t[n]),e),u=(e=[],t=(t=>e.splice(e.indexOf(t)>>>0,1)))=>[n=>(e.push(n),()=>t(n)),(...t)=>e.slice().map(e=>e(...t))];let p=()=>Object.create(null);const b=(h=r=>c=>{let a=(([,t]=o(p()))=>e(()=>t(p()),[t]))(),i=!0===c,$=t(!0);return n(()=>()=>{$.current=!1},[]),n(()=>(!i&&c?r.$select(c):r)[i?"$onAnyChange":"$onChange"](()=>$&&a()),[]),r},e=>{let t={},[n,o]=u(),p=l(()=>(!$(t)&&o(i(t)),t={}));const b=(e,o="",[f,g]=u(),m)=>{if(e.$xobi)return e;m={$use:h&&h(e),$connect:null,$xobi:{paths:{}},$notify:l(({$xobi:t}=e)=>(!$(t.paths)&&g(i(t.paths)),t.paths={})),$onChange:e=>f(e),$onAnyChange:e=>n(e),$getState:()=>i(e).reduce((t,n)=>"function"!=typeof e[n]?(t[n]=r(e[n])&&e[n].$xobi?e[n].$getState():e[n],t):t,{}),$merge:t=>(r(t)&&s(e,t),a),$select:(t,n={})=>(s(n,m),s(n,e),n.$onChange=(n,[o,r]=u(),c,a)=>(c=e.$onAnyChange((e=[])=>[].concat(t).some(t=>e.includes(t))&&r(e)),a=o(n),()=>(c(),a())),n)};for(let t in m)c(e,t,{enumerable:!1,value:m[t]});for(let n in e){let a=e[n],i=o+(o?".":"")+n;r(a)&&b(e[n],i),c(e,n,{enumerable:!0,get:()=>a,set(o){if(o!==a){if("$"===n[0])return a=o;if(r(a)&&a.$xobi&&r(o))return s(e[n],o);a=o,t[i]=e.$xobi.paths[i]=!0,p(),e.$notify()}}})}return e};return b(e)});var h;export{b as xobi};
