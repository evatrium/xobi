import{useCallback as e,useRef as t,useEffect as n,useState as o}from"react";const r=e=>"[object Object]"===Object.prototype.toString.call(e),c=(e,t,n)=>Object.defineProperty(e,t,n),i=new Promise(e=>e()),a=e=>Object.keys(e),s=e=>!a(e).length,$=(e,t=!1)=>()=>t||(t=i.then(()=>(e(),t=!1))),l=(e,t)=>(a(t).map(n=>r(e[n])&&r(t[n])?l(e[n],t[n]):e[n]=t[n]),e),u=(e=[],t=(t=>e.splice(e.indexOf(t)>>>0,1)))=>[n=>(e.push(n),()=>t(n)),(...t)=>e.slice().map(e=>e(...t))];let h=()=>Object.create(null);const b=(p=r=>c=>{let i=(([,t]=o(h()))=>e(()=>t(h()),[t]))(),a=!0===c,s=t(!0);return n(()=>()=>{s.current=!1},[]),n(()=>(!a&&c?r.$select(c):r)[a?"$onAnyChange":"$onChange"](()=>s.current&&i()),[]),r},e=>{let t={},[n,o]=u(),h=$(()=>(!s(t)&&o(a(t)),t={}));const b=(e,o="",[f,g]=u(),x)=>{if(e.$xobi)return e;x={$use:p&&p(e),$connect:()=>e=>{throw new Error('"xobi.$connect()" is depreciated. Use the "xobi.$use()" hook as described in the docs.')},$xobi:{paths:{}},$notify:$(({$xobi:t}=e)=>(!s(t.paths)&&g(a(t.paths)),t.paths={})),$onChange:e=>f(e),$onAnyChange:e=>n(e),$getState:()=>a(e).reduce((t,n)=>"function"!=typeof e[n]?(t[n]=r(e[n])&&e[n].$xobi?e[n].$getState():e[n],t):t,{}),$merge:t=>(r(t)&&l(e,t),i),$select:(t,n={})=>(l(n,x),l(n,e),n.$onChange=(n,[o,r]=u(),c,i)=>(c=e.$onAnyChange((e=[])=>[].concat(t).some(t=>e.includes(t))&&r(e)),i=o(n),()=>(c(),i())),n)};for(let t in x)c(e,t,{enumerable:!1,value:x[t]});for(let n in e){let i=e[n],a=o+(o?".":"")+n;r(i)&&b(e[n],a),c(e,n,{enumerable:!0,get:()=>i,set(o){if(o!==i){if("$"===n[0])return i=o;if(r(i)&&i.$xobi&&r(o))return l(e[n],o);i=o,t[a]=e.$xobi.paths[a]=!0,h(),e.$notify()}}})}return e};return b(e)});var p;export default b;export{b as xobi};
