import{Component as e,h as t}from"preact";import{useCallback as n,useRef as o,useEffect as r,useState as i}from"preact/hooks";const c=e=>"[object Object]"===Object.prototype.toString.call(e),s=(e,t,n)=>Object.defineProperty(e,t,n),a=new Promise(e=>e()),p=e=>Object.keys(e),$=e=>!p(e).length,l=(e,t=!1)=>()=>t||(t=a.then(()=>(e(),t=!1))),h=(e,t)=>(p(t).map(n=>c(e[n])&&c(t[n])?h(e[n],t[n]):e[n]=t[n]),e),u=(e=[],t=(t=>e.splice(e.indexOf(t)>>>0,1)))=>[n=>(e.push(n),()=>t(n)),(...t)=>e.slice().map(e=>e(...t))];let f=()=>Object.create(null);const b=(g=n=>o=>r=>{let i=!0===o;function c(){this.componentWillUnmount=(!i&&o?n.$select(o):n)[i?"$onAnyChange":"$onChange"](()=>this.setState(f())),this.render=()=>t(r,this.props,this.props.children)}return(c.prototype=new e).constructor=c},m=e=>t=>{let c=(([,e]=i(f()))=>n(()=>e(f()),[e]))(),s=!0===t,a=o(!0);return r(()=>()=>{a.current=!1},[]),r(()=>(!s&&t?e.$select(t):e)[s?"$onAnyChange":"$onChange"](()=>a&&c()),[]),e},e=>{let t={},[n,o]=u(),r=l(()=>(!$(t)&&o(p(t)),t={}));const i=(e,o="",[f,b]=u(),y)=>{if(e.$xobi)return e;y={$use:m&&m(e),$connect:g&&g(e),$xobi:{paths:{}},$notify:l(({$xobi:t}=e)=>(!$(t.paths)&&b(p(t.paths)),t.paths={})),$onChange:e=>f(e),$onAnyChange:e=>n(e),$getState:()=>p(e).reduce((t,n)=>"function"!=typeof e[n]?(t[n]=c(e[n])&&e[n].$xobi?e[n].$getState():e[n],t):t,{}),$merge:t=>(c(t)&&h(e,t),a),$select:(t,n={})=>(h(n,y),h(n,e),n.$onChange=(n,[o,r]=u(),i,c)=>(i=e.$onAnyChange((e=[])=>[].concat(t).some(t=>e.includes(t))&&r(e)),c=o(n),()=>(i(),c())),n)};for(let t in y)s(e,t,{enumerable:!1,value:y[t]});for(let n in e){let a=e[n],p=o+(o?".":"")+n;c(a)&&i(e[n],p),s(e,n,{enumerable:!0,get:()=>a,set(o){if(o!==a){if("$"===n[0])return a=o;if(c(a)&&a.$xobi&&c(o))return h(e[n],o);a=o,t[p]=e.$xobi.paths[p]=!0,r(),e.$notify()}}})}return e};return i(e)});var g,m;export{b as xobi};
