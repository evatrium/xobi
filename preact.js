import"preact";import{useCallback as e,useRef as t,useEffect as n,useState as o}from"preact/hooks";const r=e=>"[object Object]"===Object.prototype.toString.call(e),c=(e,t,n)=>Object.defineProperty(e,t,n),i=new Promise(e=>e()),a=e=>Object.keys(e),s=e=>!a(e).length,$=(e,t=!1)=>()=>t||(t=i.then(()=>(e(),t=!1))),u=(e,t)=>(a(t).map(n=>r(e[n])&&r(t[n])?u(e[n],t[n]):e[n]=t[n]),e),h=(e=[],t=(t=>e.splice(e.indexOf(t)>>>0,1)))=>[n=>(e.push(n),()=>t(n)),(...t)=>e.slice().map(e=>e(...t))];let l=()=>Object.create(null);const p=(b=r=>c=>{let i=(([,t]=o(l()))=>e(()=>t(l()),[t]))(),a=!0===c,s=t(!0);return n(()=>()=>{s.current=!1},[]),n(()=>(!a&&c?r.$select(c):r)[a?"$onAnyChange":"$onChange"](()=>s.current&&i()),[]),r},e=>{let t={},[n,o]=h(),l=$(()=>(!s(t)&&o(a(t)),t={}));const p=(e,o="",[f,g]=h(),x)=>{if(e.$xobi)return e;x={$use:b&&b(e),$connect:()=>e=>{throw new Error('"xobi.$connect()" is depreciated. Use the "xobi.$use()" hook as described in the docs, or create your own connect function with it')},$xobi:{paths:{}},$notify:$(({$xobi:t}=e)=>(!s(t.paths)&&g(a(t.paths)),t.paths={})),$onChange:e=>f(e),$onAnyChange:e=>n(e),$getState:()=>a(e).reduce((t,n)=>"function"!=typeof e[n]?(t[n]=r(e[n])&&e[n].$xobi?e[n].$getState():e[n],t):t,{}),$merge:t=>(r(t)&&u(e,t),i),$select:(t,n={})=>(u(n,x),u(n,e),n.$onChange=(n,[o,r]=h(),c,i)=>(c=e.$onAnyChange((e=[])=>[].concat(t).some(t=>e.includes(t))&&r(e)),i=o(n),()=>(c(),i())),n)};for(let t in x)c(e,t,{enumerable:!1,value:x[t]});for(let n in e){let i=e[n],a=o+(o?".":"")+n;r(i)&&p(e[n],a),c(e,n,{enumerable:!0,get:()=>i,set(o){if(o!==i){if("$"===n[0])return i=o;if(r(i)&&i.$xobi&&r(o))return u(e[n],o);i=o,t[a]=e.$xobi.paths[a]=!0,l(),e.$notify()}}})}return e};return p(e)});var b;export default p;export{p as xobi};
