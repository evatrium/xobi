const e=e=>"[object Object]"===Object.prototype.toString.call(e),t=(e,t,n)=>Object.defineProperty(e,t,n),n=new Promise(e=>e()),o=e=>Object.keys(e),i=e=>!o(e).length,r=(e,t=!1)=>()=>t||(t=n.then(()=>(e(),t=!1))),c=(t,n)=>(o(n).map(o=>e(t[o])&&e(n[o])?c(t[o],n[o]):t[o]=n[o]),t),s=(e=[],t=(t=>e.splice(e.indexOf(t)>>>0,1)))=>[n=>(e.push(n),()=>t(n)),(...t)=>e.slice().map(e=>e(...t))],$=$=>{let a={},[b,h]=s(),p=r(()=>(!i(a)&&h(o(a)),a={}));const l=($,h="",[u,f]=s(),d)=>{if($.$xobi)return $;d={$use:void 0,$connect:()=>e=>{throw new Error('"xobi.$connect()" is depreciated. Use the "xobi.$use()" hook as described in the docs.')},$xobi:{paths:{}},$notify:r(({$xobi:e}=$)=>(!i(e.paths)&&f(o(e.paths)),e.paths={})),$onChange:e=>u(e),$onAnyChange:e=>b(e),$getState:()=>o($).reduce((t,n)=>"function"!=typeof $[n]?(t[n]=e($[n])&&$[n].$xobi?$[n].$getState():$[n],t):t,{}),$merge:t=>(e(t)&&c($,t),n),$select:(e,t={})=>(c(t,d),c(t,$),t.$onChange=(t,[n,o]=s(),i,r)=>(i=$.$onAnyChange((t=[])=>[].concat(e).some(e=>t.includes(e))&&o(t)),r=n(t),()=>(i(),r())),t)};for(let e in d)t($,e,{enumerable:!1,value:d[e]});for(let n in $){let o=$[n],i=h+(h?".":"")+n;e(o)&&l($[n],i),t($,n,{enumerable:!0,get:()=>o,set(t){if(t!==o){if("$"===n[0])return o=t;if(e(o)&&o.$xobi&&e(t))return c($[n],t);o=t,a[i]=$.$xobi.paths[i]=!0,p(),$.$notify()}}})}return $};return l($)};export{$ as xobi};
