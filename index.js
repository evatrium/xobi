const e=e=>"[object Object]"===Object.prototype.toString.call(e),t=(e,t,n)=>Object.defineProperty(e,t,n),n=new Promise(e=>e()),o=e=>Object.keys(e),i=e=>!o(e).length,r=(e,t=!1)=>()=>t||(t=n.then(()=>(e(),t=!1))),c=(t,n)=>(o(n).map(o=>e(t[o])&&e(n[o])?c(t[o],n[o]):t[o]=n[o]),t),s=(e=[],t=(t=>e.splice(e.indexOf(t)>>>0,1)))=>[n=>(e.push(n),()=>t(n)),(...t)=>e.slice().map(e=>e(...t))],a=a=>{let $={},[h,b]=s(),u=r(()=>(!i($)&&b(o($)),$={}));const p=(a,b="",[l,f]=s(),d)=>{if(a.$xobi)return a;d={$use:void 0,$connect:()=>e=>{throw new Error('"xobi.$connect()" is depreciated. Use the "xobi.$use()" hook as described in the docs, or create your own connect function with it')},$xobi:{paths:{}},$notify:r(({$xobi:e}=a)=>(!i(e.paths)&&f(o(e.paths)),e.paths={})),$onChange:e=>l(e),$onAnyChange:e=>h(e),$getState:()=>o(a).reduce((t,n)=>"function"!=typeof a[n]?(t[n]=e(a[n])&&a[n].$xobi?a[n].$getState():a[n],t):t,{}),$merge:t=>(e(t)&&c(a,t),n),$select:(e,t={})=>(c(t,d),c(t,a),t.$onChange=(t,[n,o]=s(),i,r)=>(i=a.$onAnyChange((t=[])=>[].concat(e).some(e=>t.includes(e))&&o(t)),r=n(t),()=>(i(),r())),t)};for(let e in d)t(a,e,{enumerable:!1,value:d[e]});for(let n in a){let o=a[n],i=b+(b?".":"")+n;e(o)&&p(a[n],i),t(a,n,{enumerable:!0,get:()=>o,set(t){if(t!==o){if("$"===n[0])return o=t;if(e(o)&&o.$xobi&&e(t))return c(a[n],t);o=t,$[i]=a.$xobi.paths[i]=!0,u(),a.$notify()}}})}return a};return p(a)};export{a as xobi};
