const e=e=>"[object Object]"===Object.prototype.toString.call(e),t=e=>"function"==typeof e,n=(e,t,n)=>Object.defineProperty(e,t,n),r=e=>Object.keys(e),o=e=>!r(e).length,c=n=>e(n)||t(n),i=e=>c(e)&&e.$xobi,s=new Promise(e=>e()),a=e=>{let t=!1;return()=>(t||(t=s.then(()=>{e(),t=!1})),t)},u=(e,t)=>{for(let n in t)c(e[n])&&c(t[n])?u(e[n],t[n]):e[n]=t[n];return e},l=(e=[],t=(t=>e.splice(e.indexOf(t)>>>0,1)))=>[n=>(e.push(n),()=>t(n)),(...t)=>e.slice().map(e=>e(...t))],$=($,f={})=>{const h=!1===f.batch;let p={};const[b,g]=l(),y=()=>{!o(p)&&g(r(p)),p={}},m=h?y:a(y),x=($,f="")=>{if(i($))return $;const[g,y]=l(),d=()=>{const{$xobi:e}=$;!o(e.paths)&&y(r(e.paths)),e.paths={}},j={$xobi:{paths:{}},$use:void 0,$notify:h?d:a(d),$onChange:e=>g(e),$onAnyChange:e=>b(e),$getState:()=>r($).reduce((e,n)=>{let r=$[n],c=t(r);return i(r)?c&&o(r)||(e[n]=r.$getState()):c||(e[n]=r),e},{}),$merge:t=>(e(t)&&u($,t),s),$select:e=>{const t={};return u(u(t,j),$),t.$onChange=t=>{const[n,r]=l(),o=n(t),c=$.$onAnyChange((t=[])=>{[].concat(e).some(e=>t.includes(e))&&r(t)});return()=>(c(),o())},t}};for(let e in j)n($,e,{enumerable:!1,value:j[e]});for(let t in $){let r=$[t],o=f+(f?".":"")+t;c(r)&&x($[t],o),n($,t,{enumerable:!0,get:()=>r,set(n){if(n!==r){if("$"===t[0])return r=n;if(i(r)&&e(n))return u($[t],n);r=n,p[o]=$.$xobi.paths[o]=!0,m(),$.$notify()}}})}return $};return x($)};export{$ as xobi};
