const e=e=>"[object Object]"===Object.prototype.toString.call(e),t=(e,t,n)=>Object.defineProperty(e,t,n),n=new Promise(e=>e()),o=e=>Object.keys(e),i=e=>!o(e).length,r=(e,t=!1)=>()=>t||(t=n.then(()=>(e(),t=!1))),a=(t,n)=>(o(n).map(o=>e(t[o])&&e(n[o])?a(t[o],n[o]):t[o]=n[o]),t),c=(e=[],t=(t=>e.splice(e.indexOf(t)>>>0,1)))=>[n=>(e.push(n),()=>t(n)),(...t)=>e.slice().map(e=>e(...t))],$=($,s)=>l=>{let p={},[b,u]=c(),f=r(()=>(!i(p)&&u(o(p)),p={}));const h=(l,u="",[g,x]=c(),y)=>{if(l.$xobi)return l;y={$use:s&&s(l),$connect:$&&$(l),$xobi:{paths:{}},$notify:r(({$xobi:e}=l)=>(!i(e.paths)&&x(o(e.paths)),e.paths={})),$onChange:e=>g(e),$onAnyChange:e=>b(e),$getState:()=>o(l).reduce((t,n)=>"function"!=typeof l[n]?(t[n]=e(l[n])&&l[n].$xobi?l[n].$getState():l[n],t):t,{}),$merge:t=>(e(t)&&a(l,t),n),$select:(e,t={})=>(a(t,y),a(t,l),t.$onChange=(t,[n,o]=c(),i,r)=>(i=l.$onAnyChange((t=[])=>[].concat(e).some(e=>t.includes(e))&&o(t)),r=n(t),()=>(i(),r())),t)};for(let e in y)t(l,e,{enumerable:!1,value:y[e]});for(let n in l){let o=l[n],i=u+(u?".":"")+n;e(o)&&h(l[n],i),t(l,n,{enumerable:!0,get:()=>o,set(t){if(t!==o){if("$"==n[0])return o=t;if(e(o)&&o.$xobi&&e(t))return a(l[n],t);o=t,p[i]=l.$xobi.paths[i]=!0,f(),l.$notify()}}})}return l};return h(l)};export{$ as c};
