const e=e=>"object"==typeof e&&!Array.isArray(e),t=(e,t,n)=>Object.defineProperty(e,t,n),n=new Promise(e=>e()),o=e=>Object.keys(e),r=e=>!o(e).length,i=(e,t=!1)=>()=>t||(t=n.then(()=>(e(),t=!1))),a=(t,n)=>(o(n).map(o=>e(t[o])&&e(n[o])?a(t[o],n[o]):t[o]=n[o]),t),s=(e=[],t=(t=>e.splice(e.indexOf(t)>>>0,1)))=>[n=>(e.push(n),()=>t(n)),(...t)=>e.slice().map(e=>e(...t))],$=($,c)=>f=>{let p={},[u,h]=s(),l=i(()=>(!r(p)&&h(o(p)),p={}));const b=(f,h="",[y,g]=s(),m)=>{if(f.$xobi)return f;m={$use:c&&c(f),$connect:$&&$(f),$xobi:{paths:{}},$notify:i(({$xobi:e}=f)=>(!r(e.paths)&&g(o(e.paths)),e.paths={})),$onChange:e=>y(e),$onAnyChange:e=>u(e),$getState:()=>o(f).reduce((t,n)=>"function"!=typeof f[n]?(t[n]=e(f[n])&&f[n].$xobi?f[n].$getState():f[n],t):t,{}),$merge:t=>(e(t)&&a(f,t),n),$select:(e,t={})=>(a(t,m),a(t,f),t.$onChange=(t,[n,o]=s(),r,i)=>(r=f.$onAnyChange((t=[])=>[].concat(e).some(e=>t.includes(e))&&o(t)),i=n(t),()=>(r(),i())),t)};for(let e in m)t(f,e,{enumerable:!1,value:m[e]});for(let n in f){let o=f[n],r=h+(h?".":"")+n;e(o)&&b(f[n],r),t(f,n,{enumerable:!0,get:()=>o,set(t){if(t!==o){if("$"==n[0])return o=t;if(e(o)&&e(t))return a(f[n],t);o=t,p[r]=f.$xobi.paths[r]=!0,l(),f.$notify()}}})}return f};return b(f)};export{$ as c};
